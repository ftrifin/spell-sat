// ################################################################################
// FILE       : SPELLcontroller.H
// DATE       : Mar 17, 2011
// PROJECT    : SPELL
// DESCRIPTION: Controls the command processing in a separate thread.
// --------------------------------------------------------------------------------
//
//  Copyright (C) 2008, 2011 SES ENGINEERING, Luxembourg S.A.R.L.
//
//  This file is part of SPELL.
//
// SPELL is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// SPELL is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with SPELL. If not, see <http://www.gnu.org/licenses/>.
//
// ################################################################################

#ifndef __SPELL_CONTROLLER_H__
#define __SPELL_CONTROLLER_H__

// FILES TO INCLUDE ////////////////////////////////////////////////////////
// System includes ---------------------------------------------------------
// Local includes ----------------------------------------------------------
#include "SPELL_EXC/SPELLcontrollerIF.H"
#include "SPELL_EXC/SPELLcommandMailbox.H"
// Project includes --------------------------------------------------------
#include "SPELL_SYN/SPELLthread.H"
#include "SPELL_SYN/SPELLevent.H"


/** \addtogroup SPELL_EXC */
/*@{*/


// FORWARD REFERENCES //////////////////////////////////////////////////////
// TYPES ///////////////////////////////////////////////////////////////////
// DEFINES /////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
/**
 ** \brief Command controller thread
 **
 ** \par Description and usage:
 **
 **		Processes the commands received from the client and keeps the
 **		procedure status.
 **
 **	\see SPELLcontrollerIF.
 **
**////////////////////////////////////////////////////////////////////////////
class SPELLcontroller: public SPELLthread, public SPELLcontrollerIF
{
public: //--------------------------------------------------------------------

    // EXCEPTIONS ////////////////////////////////////////////////////////////
    // ENUMS /////////////////////////////////////////////////////////////////
    // TYPES /////////////////////////////////////////////////////////////////
    // LIFECYCLE /////////////////////////////////////////////////////////////

		//////////////////////////////////////////////////////////////////////
		/** Constructor.
		**////////////////////////////////////////////////////////////////////
		SPELLcontroller();

		//////////////////////////////////////////////////////////////////////
		/** Destructor.
		**////////////////////////////////////////////////////////////////////
		~SPELLcontroller();

    // STATIC ////////////////////////////////////////////////////////////////

    // METHODS ///////////////////////////////////////////////////////////////

		//////////////////////////////////////////////////////////////////////
		/** Thread main function. Will be in charge of process all incoming
		 * commands for the executor, queue them appropriately and act
		 * accordingly.
		**////////////////////////////////////////////////////////////////////
		void run();

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLcontrollerIF.
		**////////////////////////////////////////////////////////////////////
		void begin() { start(); };

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLcontrollerIF.
		**////////////////////////////////////////////////////////////////////
		void stop();

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLcontrollerIF.
		**////////////////////////////////////////////////////////////////////
		void reset();

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLcontrollerIF.
		**////////////////////////////////////////////////////////////////////
		void command( const ExecutorCommand& cmd, const bool queueIt, const bool high_priority );

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLcontrollerIF.
		**////////////////////////////////////////////////////////////////////
		const bool shouldReload() const { return m_reload; };

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLcontrollerIF.
		**////////////////////////////////////////////////////////////////////
		const bool shouldRecover();

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLcontrollerIF.
		**////////////////////////////////////////////////////////////////////
		const SPELLexecutorStatus getStatus() const;

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLcontrollerIF.
		**////////////////////////////////////////////////////////////////////
		const SPELLexecutionMode getMode() const;

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLcontrollerIF.
		**////////////////////////////////////////////////////////////////////
		void setStatus( const SPELLexecutorStatus& st );

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLcontrollerIF.
		**////////////////////////////////////////////////////////////////////
		void setMode( const SPELLexecutionMode& mode );

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLcontrollerIF.
		**////////////////////////////////////////////////////////////////////
		void setCondition( const std::string& condition );

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLcontrollerIF.
		**////////////////////////////////////////////////////////////////////
		const std::string& getCondition() const;

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLcontrollerIF.
		**////////////////////////////////////////////////////////////////////
		const bool hasCondition() const;

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLcontrollerIF.
		**////////////////////////////////////////////////////////////////////
		void setAutoRun();

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLcontrollerIF.
		**////////////////////////////////////////////////////////////////////
		void setExecutionDelay( const long delay );

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLcontrollerIF.
		**////////////////////////////////////////////////////////////////////
		void enableRunInto( const bool enable );

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLcontrollerIF.
		**////////////////////////////////////////////////////////////////////
		const bool checkAborted();

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLcontrollerIF.
		**////////////////////////////////////////////////////////////////////
		void executionLock();

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLcontrollerIF.
		**////////////////////////////////////////////////////////////////////
		void executionUnlock();

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLcontrollerIF.
		**////////////////////////////////////////////////////////////////////
		const bool event_line( const std::string& file, const int& line, const std::string& name, bool executable );

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLcontrollerIF.
		**////////////////////////////////////////////////////////////////////
		void event_call( const std::string& file, const int& line, const std::string& name);

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLcontrollerIF.
		**////////////////////////////////////////////////////////////////////
		void event_return( const std::string& file, const int& line, const std::string& name);

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLcontrollerIF.
		**////////////////////////////////////////////////////////////////////
		void setStartTime();

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLcontrollerIF.
		**////////////////////////////////////////////////////////////////////
		void setEndTime();

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLcontrollerIF.
		**////////////////////////////////////////////////////////////////////
		void setFinished();

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLcontrollerIF.
		**////////////////////////////////////////////////////////////////////
		void setError( const std::string& error, const std::string& reason, const bool fatal );

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLcontrollerIF.
		**////////////////////////////////////////////////////////////////////
		void waitCommand();

    // DATA MEMBERS //////////////////////////////////////////////////////////

protected: //-----------------------------------------------------------------

    // EXCEPTIONS ////////////////////////////////////////////////////////////
    // ENUMS /////////////////////////////////////////////////////////////////
    // TYPES /////////////////////////////////////////////////////////////////
    // LIFECYCLE /////////////////////////////////////////////////////////////
    // METHODS ///////////////////////////////////////////////////////////////

		//////////////////////////////////////////////////////////////////////
		/** Perform the STEP or STEP_OVER command operations.
		 *
		 * \param stepOver IN: if true, execute STEP_OVER.
		**////////////////////////////////////////////////////////////////////
		void doStep( const bool stepOver );

		//////////////////////////////////////////////////////////////////////
		/** Perform the RUN command operations.
		**////////////////////////////////////////////////////////////////////
		void doPlay();

		//////////////////////////////////////////////////////////////////////
		/** Perform the PAUSE command operations.
		 *
		 * \param synchronizeWithDispatcher IN: wait for dispatcher mechanism
		 * before actually pausing
		**////////////////////////////////////////////////////////////////////
		void doPause( bool synchronizeWithDispatcher );

		//////////////////////////////////////////////////////////////////////
		/** Perform the ABORT command operations.
		**////////////////////////////////////////////////////////////////////
		void doAbort();

		//////////////////////////////////////////////////////////////////////
		/** Perform the finish command operations.
		**////////////////////////////////////////////////////////////////////
		void doFinish();

		//////////////////////////////////////////////////////////////////////
		/** Prepare to close the procedure (actual closure is done by the
		 * interpreter object)
		**////////////////////////////////////////////////////////////////////
		void doClose();

		//////////////////////////////////////////////////////////////////////
		/** Prepare to reload the procedure (actual reload is done by the
		 * interpreter object)
		**////////////////////////////////////////////////////////////////////
		void doReload();

		//////////////////////////////////////////////////////////////////////
		/** Prepare to recover the procedure (actual recovery is done by the
		 * interpreter object)
		**////////////////////////////////////////////////////////////////////
		void doRecover();

		//////////////////////////////////////////////////////////////////////
		/** Perform the SKIP command operations.
		**////////////////////////////////////////////////////////////////////
		void doSkip();

		//////////////////////////////////////////////////////////////////////
		/** Perform the GOTO(label) command operations.
		**////////////////////////////////////////////////////////////////////
		void doGoto( const std::string& label );

		//////////////////////////////////////////////////////////////////////
		/** Perform the GOTO(line) command operations.
		**////////////////////////////////////////////////////////////////////
		void doGoto( const int line );

		//////////////////////////////////////////////////////////////////////
		/** Perform the SCRIPT command operations.
		**////////////////////////////////////////////////////////////////////
		void doScript( const std::string& script, const bool override );

		//////////////////////////////////////////////////////////////////////
		/** Perform the ACTION command operation
		**////////////////////////////////////////////////////////////////////
		void doUserAction();

		//////////////////////////////////////////////////////////////////////
		/** Block the dispatcher (stepping/pause mechanism)
		**////////////////////////////////////////////////////////////////////
		void doWait();

		//////////////////////////////////////////////////////////////////////
		/** Unblock the dispatcher (stepping/pause mechanism)
		**////////////////////////////////////////////////////////////////////
		void doContinue();

		//////////////////////////////////////////////////////////////////////
		/** Unblock the dispatcher (stepping/pause mechanism)
		**////////////////////////////////////////////////////////////////////
		void executeCommand( const ExecutorCommand& cmd );

    // DATA MEMBERS //////////////////////////////////////////////////////////

private: //-------------------------------------------------------------------

    // EXCEPTIONS ////////////////////////////////////////////////////////////
    // ENUMS /////////////////////////////////////////////////////////////////
    // TYPES /////////////////////////////////////////////////////////////////
    // LIFECYCLE /////////////////////////////////////////////////////////////
    // METHODS ///////////////////////////////////////////////////////////////
    // DATA MEMBERS //////////////////////////////////////////////////////////
		/** Holds the execution of a command until ready */
		SPELLevent           m_goCommand;
		/** Holds the dispatching until command is executed */
		SPELLevent           m_commandExecuted;
		/** Event used for the stepping/pause mechanism (dispatcher blockage) */
		SPELLevent           m_execLock;
		/** Event used for the language lock (command processing) */
		SPELLevent           m_controllerLock;
		/** Event used for blocking the interpreter object until the recovery
		feasibility is determined and the executor is in the proper state. */
		SPELLevent           m_recoverEvent;
		/** Holds the current execution status. */
		SPELLexecutorStatus   m_status;
		/** Holds the current execution mode. */
		SPELLexecutionMode    m_mode;
		/** Reference to the mailbox object. */
		SPELLcommandMailbox   m_mailbox;
		/** Holds the programmed execution delay in msec. */
		long m_execDelay;
		/** True if the skip-out-function mechanism is being used. */
		bool m_skipping;
		/** True if the procedure has been aborted. */
		bool m_abort;
		/** True if the procedure is finished. */
		bool m_finished;
		/** True if the procedure is in error state. */
		bool m_error;
		/** True if the procedure shall go to play mode right away after load. */
		bool m_autorun;
		/** True if the procedure can recover state. */
		bool m_recover;
		/** True if the user requires the procedure to be reloaded. */
		bool m_reload;
		/** True if the user wants to pause. Required for pausing during step overs */
		bool m_wantPause;
		/** Holds the name of the main procedure file. */
		std::string m_mainProc;
		/** Holds the name of the current procedure file. */
		std::string m_currentProc;
		/** Holds the scheduling condition, if any */
		std::string m_condition;
};

/*@}*/
#endif
