// ################################################################################
// FILE       : SPELLexecutorImpl.H
// DATE       : Mar 17, 2011
// PROJECT    : SPELL
// DESCRIPTION: Implementation of the Executor.
// --------------------------------------------------------------------------------
//
//  Copyright (C) 2008, 2011 SES ENGINEERING, Luxembourg S.A.R.L.
//
//  This file is part of SPELL.
//
// SPELL is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// SPELL is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with SPELL. If not, see <http://www.gnu.org/licenses/>.
//
// ################################################################################

#ifndef __SPELL_EXECUTOR_IMPL_H__
#define __SPELL_EXECUTOR_IMPL_H__

// FILES TO INCLUDE ////////////////////////////////////////////////////////
// Local includes ----------------------------------------------------------
#include "SPELL_EXC/SPELLexecutorIF.H"
#include "SPELL_EXC/SPELLimportChecker.H"
#include "SPELL_EXC/SPELLbreakpointType.H"
// Project includes --------------------------------------------------------
// System includes ---------------------------------------------------------


/** \addtogroup SPELL_EXC */
/*@{*/


// FORWARD REFERENCES //////////////////////////////////////////////////////
// TYPES ///////////////////////////////////////////////////////////////////
// DEFINES /////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
/**
 ** \brief Main implementation of the procedure executor
 **
 ** \par Description and usage:
 **
 **		Main implementation of the SPELLexecutorIF interface for the SPELL
 **		Executor process.
 **
**////////////////////////////////////////////////////////////////////////////
class SPELLexecutorImpl: public SPELLexecutorIF
{
public: //--------------------------------------------------------------------

    // EXCEPTIONS ////////////////////////////////////////////////////////////
    // ENUMS /////////////////////////////////////////////////////////////////
    // TYPES /////////////////////////////////////////////////////////////////
    // LIFECYCLE /////////////////////////////////////////////////////////////

		//////////////////////////////////////////////////////////////////////
		/** Constructor
		**////////////////////////////////////////////////////////////////////
		SPELLexecutorImpl();

		//////////////////////////////////////////////////////////////////////
		/** Destructor.
		**////////////////////////////////////////////////////////////////////
		virtual ~SPELLexecutorImpl();

    // STATIC ////////////////////////////////////////////////////////////////
    // METHODS ///////////////////////////////////////////////////////////////

    // *******************************************************************
    // INITIALIZATION
    // *******************************************************************

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		void initialize( SPELLcif* cif,
						 SPELLcontrollerIF* controller,
						 SPELLschedulerIF* scheduler,
						 SPELLcallstackIF* callstack,
						 SPELLexecutionFrame* frame );

	    //////////////////////////////////////////////////////////////////////
	    /** \see SPELLexecutorIF.
	    **////////////////////////////////////////////////////////////////////
	    void prepare( const std::string& procId, const SPELLcontextConfig& ctxConfig );

	// *******************************************************************
	// COMPONENT ACCESSORS
	// *******************************************************************

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		SPELLcif& getCIF() const { return *m_cif; };

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		SPELLcallstackIF& getCallstack() const { return *m_callstack; };

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		SPELLcontrollerIF& getController() const { return *m_controller; };

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		SPELLschedulerIF& getScheduler() const { return *m_scheduler; };

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		SPELLchildManager& getChildManager() const { return *m_childMgr; };

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		SPELLexecutorConfig& getConfiguration() const { return *m_config; };

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		SPELLvariableManager& getVariableManager() const { return *m_varManager; };

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		SPELLexecutionFrame& getFrame() const { return *m_frame; };

    // *******************************************************************
    // EXECUTION ENTRY POINTS
    // *******************************************************************

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		void execute();

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		void recover();

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		void finalize();

    // *******************************************************************
    // MAIN EXECUTION CONTROL
    // *******************************************************************

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		void dispatch( PyObject* obj, PyFrameObject* frame, int what, PyObject* args );

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		void command( const ExecutorCommand& cmd, const bool high_priority );

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		void abort( const std::string& message, bool systemAborted );

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		void finish( const std::string& message );

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		void pause();

    // *******************************************************************
    // STATUS INFORMATION
    // *******************************************************************

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		const SPELLexecutorStatus getStatus() const;

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		const std::string getContextName() const;

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		const std::string getProcId() const;

    // *******************************************************************
    // EXECUTION CONFIGURATION PARAMETERS
    // *******************************************************************

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		void setProcedurePath( const std::string& procPath ) { m_procPath = procPath; };

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		void setLibraryPath( const std::string& libPath ) { m_libPath = libPath; };

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		void setRunInto( const bool enabled );

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		void setByStep( const bool enabled );

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		void setBrowsableLib( const bool enabled );

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		void setExecDelay( const int delay );

    // *******************************************************************
    // LANGUAGE INTERLOCK
    // *******************************************************************

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		void processLock();

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		void processUnlock();

    // *******************************************************************
    // EXECUTION MANIPULATION
    // *******************************************************************

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		const bool canSkip();

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		const bool goNextLine();

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		const bool goLabel( const std::string& label, bool programmed );

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		const bool goLine( const int line );

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		const bool setBreakpoint( const std::string& file,
				                  const unsigned int line,
				                  const SPELLbreakpointType type );

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		void clearBreakpoints();

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		const bool runScript( const std::string& script );

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		void executeUserAction();

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		void setUserAction( const std::string& functionName, const std::string& actionLabel, const unsigned int severity );

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		void enableUserAction( const bool enable );

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		void dismissUserAction();

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		const std::string getUserActionLabel() const { return m_userActionLabel; };

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		const bool getUserActionEnabled() const { return m_userActionEnabled; };

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		void stage( const std::string& id, const std::string& title );

    // DATA MEMBERS //////////////////////////////////////////////////////////

protected: //-----------------------------------------------------------------

    // EXCEPTIONS ////////////////////////////////////////////////////////////
    // ENUMS /////////////////////////////////////////////////////////////////
		/** Identifies the status after an error recovery */
		typedef enum AfterError_
		{
			CANNOT_RECOVER,	// Will not recover because there is no ws support
			CANCEL_RECOVER, // Will not recover because the user does not want
			RECOVER_SUCCESS,// Recovery ok
			RECOVER_FAILED  // Recovery failed
		}
		AfterError;
    // TYPES /////////////////////////////////////////////////////////////////
    // LIFECYCLE /////////////////////////////////////////////////////////////
    // METHODS ///////////////////////////////////////////////////////////////

		//////////////////////////////////////////////////////////////////////
		/** Set the procedure identifier.
		 *
		 * \param procId IN: procedure identifier.
		**////////////////////////////////////////////////////////////////////
		void setProcId( const std::string& procId ) { m_procId = procId; };

		//////////////////////////////////////////////////////////////////////
		/** \see SPELLexecutorIF.
		**////////////////////////////////////////////////////////////////////
		void setContextName( const std::string& ctxName ) { m_contextName = ctxName; };

		//////////////////////////////////////////////////////////////////////
		/** By-Step implementation. If the feature is enabled and the current
		 * procedure line is a Step, pause the execution.
		 *
		 * \param frameLine IN: the current line in the procedure.
		**////////////////////////////////////////////////////////////////////
		const bool checkByStep( const int& frameLine );

		//////////////////////////////////////////////////////////////////////
		/** INIT step feature checker
		 *
		 * \param frameLine IN: the current line in the procedure.
		 *
		 * \returns True if the dispatching shall be aborted and control
		 *  returned to Python side immediately.
		**////////////////////////////////////////////////////////////////////
		const bool checkInitStep( const int& frameLine );

		//////////////////////////////////////////////////////////////////////
		/** Breakpoint checker. If a breakpoint is set, pause the execution.
		 *
		 * \param file IN: current file name.
		 * \param lineNo IN: the current line in the procedure.
		 *
		**////////////////////////////////////////////////////////////////////
		void checkBreakpoint( const std::string& file, unsigned int lineNo );

		//////////////////////////////////////////////////////////////////////
		/** Error recovery implementation
		 *
		 * \returns True if the error can be recovered
		**////////////////////////////////////////////////////////////////////
		const AfterError handleExecutionError();

		//////////////////////////////////////////////////////////////////////
		/** Load execution environment data and instances
		**////////////////////////////////////////////////////////////////////
		void loadExecutionEnvironment();

		//////////////////////////////////////////////////////////////////////
		/** Load SPELL driver
		**////////////////////////////////////////////////////////////////////
		void loadDriver();

		//////////////////////////////////////////////////////////////////////
		/** Unload SPELL driver.
		 *
		 * \param shutdown IN: If true, unload completely all data. If false,
		 *  just cleanup the driver, but do not remove it completely (this
		 *  is handled on driver side, not in executor)
		**////////////////////////////////////////////////////////////////////
		void unloadDriver( bool shutdown );

		//////////////////////////////////////////////////////////////////////
		/** Called when the execution finishes with errors. The behavior
		 * depends on the recovery mechanism status and user's choice.
		 *
		 * \return True if the execution shall be started over.
		**////////////////////////////////////////////////////////////////////
		bool executorFinishedWithErrors();

		//////////////////////////////////////////////////////////////////////
		/** Called when the execution finishes sucessfully. The behavior
		 * depends on the user's choice.
		 *
		 * \return True if the execution shall be started over.
		**////////////////////////////////////////////////////////////////////
		bool executorFinishedRight();

		//////////////////////////////////////////////////////////////////////
		/** Called when the execution is aborted. The behavior
		 * depends on the user's choice.
		 *
		 * \return True if the execution shall be started over.
		**////////////////////////////////////////////////////////////////////
		bool executorAborted();

		//////////////////////////////////////////////////////////////////////
		/** Waits for the user's choice: close the procedure or reload it.
		 *
		 * \return True if the execution shall be started over.
		**////////////////////////////////////////////////////////////////////
		bool reloadOrClose();

    // DATA MEMBERS //////////////////////////////////////////////////////////

private: //-------------------------------------------------------------------

    // EXCEPTIONS ////////////////////////////////////////////////////////////
    // ENUMS /////////////////////////////////////////////////////////////////
    // TYPES /////////////////////////////////////////////////////////////////
    // LIFECYCLE /////////////////////////////////////////////////////////////
    // METHODS ///////////////////////////////////////////////////////////////
    // DATA MEMBERS //////////////////////////////////////////////////////////

		/** True if the initial configuration parameters have been set */
		bool                         m_initialized;
		/** Holds the procedure identifier */
		std::string                  m_procId;
		/** Holds the parent procedure, if any */

		std::string                  m_parentId;
		/** Holds the child procedure, if any */
		std::string                  m_childId;

		/** Used for dispatching filter (procedures) */
		std::string                  m_procPath;
		/** Used for dispatching filter (user library) */
		std::string                  m_libPath;
		/** Holds the context name */
		std::string                  m_contextName;

		/** Holds the key of the controlling client, if any */
		std::string                  m_controllingClient;
		/** Holds the list of monitoring clients, if any */
		std::vector<std::string>     m_monitoringClients;

		/** Holds the executor startup configuration */
		SPELLexecutorConfig*      	 m_config;
		/** True when the INIT step, if any, has been reached */
		bool                         m_initStepDone;
		/** Holds the user action function name if any */
		std::string                  m_userActionFunction;
		/** Holds the user action label if any */
		std::string                  m_userActionLabel;
		/** Holds the enable/disable status of the user action */
		bool						 m_userActionEnabled;
		/** Holds the severity of the action */
		unsigned int                 m_userActionSeverity;

		/** Holds the command controller */
		SPELLcontrollerIF*           m_controller;
		/** Holds the scheduler controller */
		SPELLschedulerIF*            m_scheduler;
		/** Holds the callstack model */
		SPELLcallstackIF*            m_callstack;
		/** Holds the reference to client interface */
		SPELLcif*                    m_cif;
		/** Holds the child procedure manager */
		SPELLchildManager*           m_childMgr;
		/** Holds the execution control frame */
		SPELLexecutionFrame*         m_frame;
		/** Holds the module import checker */
		SPELLimportChecker           m_importChecker;
		/** Holds the variable manager */
		SPELLvariableManager*        m_varManager;

		/** Command synchronization lock */
		SPELLmutex                   m_cmdLock;
		/** Dispatch synchronization lock */
		SPELLmutex                   m_dspLock;

		/** Next programmed goto target */
		std::string                  m_gotoTarget;

		/** True if an error crashing the procedure has happened */
		bool                         m_executionError;
};

/*@}*/
#endif
